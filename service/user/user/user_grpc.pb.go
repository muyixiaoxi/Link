// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.2
// source: service/user/user.proto

package user

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	UserService_UserCreate_FullMethodName       = "/user.UserService/UserCreate"
	UserService_UserLogin_FullMethodName        = "/user.UserService/UserLogin"
	UserService_UserInfo_FullMethodName         = "/user.UserService/UserInfo"
	UserService_UserUpdateInfo_FullMethodName   = "/user.UserService/UserUpdateInfo"
	UserService_UserFlowed_FullMethodName       = "/user.UserService/UserFlowed"
	UserService_UserUpdateRemark_FullMethodName = "/user.UserService/UserUpdateRemark"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	UserCreate(ctx context.Context, in *UserCreateRequest, opts ...grpc.CallOption) (*UserCreateResponse, error)
	UserLogin(ctx context.Context, in *UserLoginRequest, opts ...grpc.CallOption) (*UserLoginResponse, error)
	UserInfo(ctx context.Context, in *UserInfoRequest, opts ...grpc.CallOption) (*UserInfoResponse, error)
	UserUpdateInfo(ctx context.Context, in *UserUpdateInfoRequest, opts ...grpc.CallOption) (*Empty, error)
	UserFlowed(ctx context.Context, in *UserAddRequest, opts ...grpc.CallOption) (*Empty, error)
	UserUpdateRemark(ctx context.Context, in *UserUpdateRemarkRequest, opts ...grpc.CallOption) (*Empty, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) UserCreate(ctx context.Context, in *UserCreateRequest, opts ...grpc.CallOption) (*UserCreateResponse, error) {
	out := new(UserCreateResponse)
	err := c.cc.Invoke(ctx, UserService_UserCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UserLogin(ctx context.Context, in *UserLoginRequest, opts ...grpc.CallOption) (*UserLoginResponse, error) {
	out := new(UserLoginResponse)
	err := c.cc.Invoke(ctx, UserService_UserLogin_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UserInfo(ctx context.Context, in *UserInfoRequest, opts ...grpc.CallOption) (*UserInfoResponse, error) {
	out := new(UserInfoResponse)
	err := c.cc.Invoke(ctx, UserService_UserInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UserUpdateInfo(ctx context.Context, in *UserUpdateInfoRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserService_UserUpdateInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UserFlowed(ctx context.Context, in *UserAddRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserService_UserFlowed_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UserUpdateRemark(ctx context.Context, in *UserUpdateRemarkRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserService_UserUpdateRemark_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility
type UserServiceServer interface {
	UserCreate(context.Context, *UserCreateRequest) (*UserCreateResponse, error)
	UserLogin(context.Context, *UserLoginRequest) (*UserLoginResponse, error)
	UserInfo(context.Context, *UserInfoRequest) (*UserInfoResponse, error)
	UserUpdateInfo(context.Context, *UserUpdateInfoRequest) (*Empty, error)
	UserFlowed(context.Context, *UserAddRequest) (*Empty, error)
	UserUpdateRemark(context.Context, *UserUpdateRemarkRequest) (*Empty, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserServiceServer struct {
}

func (UnimplementedUserServiceServer) UserCreate(context.Context, *UserCreateRequest) (*UserCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserCreate not implemented")
}
func (UnimplementedUserServiceServer) UserLogin(context.Context, *UserLoginRequest) (*UserLoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserLogin not implemented")
}
func (UnimplementedUserServiceServer) UserInfo(context.Context, *UserInfoRequest) (*UserInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfo not implemented")
}
func (UnimplementedUserServiceServer) UserUpdateInfo(context.Context, *UserUpdateInfoRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserUpdateInfo not implemented")
}
func (UnimplementedUserServiceServer) UserFlowed(context.Context, *UserAddRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserFlowed not implemented")
}
func (UnimplementedUserServiceServer) UserUpdateRemark(context.Context, *UserUpdateRemarkRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserUpdateRemark not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_UserCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UserCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UserCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UserCreate(ctx, req.(*UserCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UserLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserLoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UserLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UserLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UserLogin(ctx, req.(*UserLoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UserInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UserInfo(ctx, req.(*UserInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UserUpdateInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserUpdateInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UserUpdateInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UserUpdateInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UserUpdateInfo(ctx, req.(*UserUpdateInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UserFlowed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UserFlowed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UserFlowed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UserFlowed(ctx, req.(*UserAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UserUpdateRemark_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserUpdateRemarkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UserUpdateRemark(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UserUpdateRemark_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UserUpdateRemark(ctx, req.(*UserUpdateRemarkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UserCreate",
			Handler:    _UserService_UserCreate_Handler,
		},
		{
			MethodName: "UserLogin",
			Handler:    _UserService_UserLogin_Handler,
		},
		{
			MethodName: "UserInfo",
			Handler:    _UserService_UserInfo_Handler,
		},
		{
			MethodName: "UserUpdateInfo",
			Handler:    _UserService_UserUpdateInfo_Handler,
		},
<<<<<<< HEAD
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/user/user.proto",
}

const (
	UserContactService_UserFlowed_FullMethodName       = "/user.UserContactService/UserFlowed"
	UserContactService_UserUpdateRemark_FullMethodName = "/user.UserContactService/UserUpdateRemark"
)

// UserContactServiceClient is the client API for UserContactService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserContactServiceClient interface {
	UserFlowed(ctx context.Context, in *UserAddRequest, opts ...grpc.CallOption) (*Empty, error)
	UserUpdateRemark(ctx context.Context, in *UserUpdateRemarkRequest, opts ...grpc.CallOption) (*Empty, error)
}

type userContactServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserContactServiceClient(cc grpc.ClientConnInterface) UserContactServiceClient {
	return &userContactServiceClient{cc}
}

func (c *userContactServiceClient) UserFlowed(ctx context.Context, in *UserAddRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserContactService_UserFlowed_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userContactServiceClient) UserUpdateRemark(ctx context.Context, in *UserUpdateRemarkRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserContactService_UserUpdateRemark_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserContactServiceServer is the server API for UserContactService service.
// All implementations must embed UnimplementedUserContactServiceServer
// for forward compatibility
type UserContactServiceServer interface {
	UserFlowed(context.Context, *UserAddRequest) (*Empty, error)
	UserUpdateRemark(context.Context, *UserUpdateRemarkRequest) (*Empty, error)
	mustEmbedUnimplementedUserContactServiceServer()
}

// UnimplementedUserContactServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserContactServiceServer struct {
}

func (UnimplementedUserContactServiceServer) UserFlowed(context.Context, *UserAddRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserFlowed not implemented")
}
func (UnimplementedUserContactServiceServer) UserUpdateRemark(context.Context, *UserUpdateRemarkRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserUpdateRemark not implemented")
}
func (UnimplementedUserContactServiceServer) mustEmbedUnimplementedUserContactServiceServer() {}

// UnsafeUserContactServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserContactServiceServer will
// result in compilation errors.
type UnsafeUserContactServiceServer interface {
	mustEmbedUnimplementedUserContactServiceServer()
}

func RegisterUserContactServiceServer(s grpc.ServiceRegistrar, srv UserContactServiceServer) {
	s.RegisterService(&UserContactService_ServiceDesc, srv)
}

func _UserContactService_UserFlowed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserContactServiceServer).UserFlowed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserContactService_UserFlowed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserContactServiceServer).UserFlowed(ctx, req.(*UserAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserContactService_UserUpdateRemark_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserUpdateRemarkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserContactServiceServer).UserUpdateRemark(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserContactService_UserUpdateRemark_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserContactServiceServer).UserUpdateRemark(ctx, req.(*UserUpdateRemarkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserContactService_ServiceDesc is the grpc.ServiceDesc for UserContactService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserContactService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.UserContactService",
	HandlerType: (*UserContactServiceServer)(nil),
	Methods: []grpc.MethodDesc{
=======
>>>>>>> aea6025d2fc2a6a17c8bc2f6d4192501ffb119bf
		{
			MethodName: "UserFlowed",
			Handler:    _UserService_UserFlowed_Handler,
		},
		{
			MethodName: "UserUpdateRemark",
			Handler:    _UserService_UserUpdateRemark_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/user/user.proto",
}

const (
	UserGroupService_UserCreateGroup_FullMethodName = "/user.UserGroupService/UserCreateGroup"
)

// UserGroupServiceClient is the client API for UserGroupService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserGroupServiceClient interface {
	UserCreateGroup(ctx context.Context, in *UserCreateGroupRequest, opts ...grpc.CallOption) (*Empty, error)
}

type userGroupServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserGroupServiceClient(cc grpc.ClientConnInterface) UserGroupServiceClient {
	return &userGroupServiceClient{cc}
}

func (c *userGroupServiceClient) UserCreateGroup(ctx context.Context, in *UserCreateGroupRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserGroupService_UserCreateGroup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserGroupServiceServer is the server API for UserGroupService service.
// All implementations must embed UnimplementedUserGroupServiceServer
// for forward compatibility
type UserGroupServiceServer interface {
	UserCreateGroup(context.Context, *UserCreateGroupRequest) (*Empty, error)
	mustEmbedUnimplementedUserGroupServiceServer()
}

// UnimplementedUserGroupServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserGroupServiceServer struct {
}

func (UnimplementedUserGroupServiceServer) UserCreateGroup(context.Context, *UserCreateGroupRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserCreateGroup not implemented")
}
func (UnimplementedUserGroupServiceServer) mustEmbedUnimplementedUserGroupServiceServer() {}

// UnsafeUserGroupServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserGroupServiceServer will
// result in compilation errors.
type UnsafeUserGroupServiceServer interface {
	mustEmbedUnimplementedUserGroupServiceServer()
}

func RegisterUserGroupServiceServer(s grpc.ServiceRegistrar, srv UserGroupServiceServer) {
	s.RegisterService(&UserGroupService_ServiceDesc, srv)
}

func _UserGroupService_UserCreateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCreateGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserGroupServiceServer).UserCreateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserGroupService_UserCreateGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserGroupServiceServer).UserCreateGroup(ctx, req.(*UserCreateGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserGroupService_ServiceDesc is the grpc.ServiceDesc for UserGroupService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserGroupService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.UserGroupService",
	HandlerType: (*UserGroupServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UserCreateGroup",
			Handler:    _UserGroupService_UserCreateGroup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/user/user.proto",
}

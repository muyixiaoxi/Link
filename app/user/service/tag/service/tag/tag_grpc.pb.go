// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.2
// source: app/user/service/tag/service/tag.proto

package tag

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	TagLogin_CreateTag_FullMethodName            = "/tag.TagLogin/CreateTag"
	TagLogin_UpdateTag_FullMethodName            = "/tag.TagLogin/UpdateTag"
	TagLogin_DeleteTag_FullMethodName            = "/tag.TagLogin/DeleteTag"
	TagLogin_SelectGroupTag_FullMethodName       = "/tag.TagLogin/SelectGroupTag"
	TagLogin_SelectAllTagsByGroup_FullMethodName = "/tag.TagLogin/SelectAllTagsByGroup"
)

// TagLoginClient is the client API for TagLogin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TagLoginClient interface {
	CreateTag(ctx context.Context, in *CreateTagRequest, opts ...grpc.CallOption) (*CreateTagResponse, error)
	UpdateTag(ctx context.Context, in *CreateTagRequest, opts ...grpc.CallOption) (*CreateTagResponse, error)
	DeleteTag(ctx context.Context, in *DeleteTagRequest, opts ...grpc.CallOption) (*DeleteTagResponse, error)
	SelectGroupTag(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GroupTagResponse, error)
	SelectAllTagsByGroup(ctx context.Context, in *SelectAllTagsByGroupName, opts ...grpc.CallOption) (*AllTagsByGroupNameResponse, error)
}

type tagLoginClient struct {
	cc grpc.ClientConnInterface
}

func NewTagLoginClient(cc grpc.ClientConnInterface) TagLoginClient {
	return &tagLoginClient{cc}
}

func (c *tagLoginClient) CreateTag(ctx context.Context, in *CreateTagRequest, opts ...grpc.CallOption) (*CreateTagResponse, error) {
	out := new(CreateTagResponse)
	err := c.cc.Invoke(ctx, TagLogin_CreateTag_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagLoginClient) UpdateTag(ctx context.Context, in *CreateTagRequest, opts ...grpc.CallOption) (*CreateTagResponse, error) {
	out := new(CreateTagResponse)
	err := c.cc.Invoke(ctx, TagLogin_UpdateTag_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagLoginClient) DeleteTag(ctx context.Context, in *DeleteTagRequest, opts ...grpc.CallOption) (*DeleteTagResponse, error) {
	out := new(DeleteTagResponse)
	err := c.cc.Invoke(ctx, TagLogin_DeleteTag_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagLoginClient) SelectGroupTag(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GroupTagResponse, error) {
	out := new(GroupTagResponse)
	err := c.cc.Invoke(ctx, TagLogin_SelectGroupTag_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagLoginClient) SelectAllTagsByGroup(ctx context.Context, in *SelectAllTagsByGroupName, opts ...grpc.CallOption) (*AllTagsByGroupNameResponse, error) {
	out := new(AllTagsByGroupNameResponse)
	err := c.cc.Invoke(ctx, TagLogin_SelectAllTagsByGroup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TagLoginServer is the server API for TagLogin service.
// All implementations must embed UnimplementedTagLoginServer
// for forward compatibility
type TagLoginServer interface {
	CreateTag(context.Context, *CreateTagRequest) (*CreateTagResponse, error)
	UpdateTag(context.Context, *CreateTagRequest) (*CreateTagResponse, error)
	DeleteTag(context.Context, *DeleteTagRequest) (*DeleteTagResponse, error)
	SelectGroupTag(context.Context, *Empty) (*GroupTagResponse, error)
	SelectAllTagsByGroup(context.Context, *SelectAllTagsByGroupName) (*AllTagsByGroupNameResponse, error)
	mustEmbedUnimplementedTagLoginServer()
}

// UnimplementedTagLoginServer must be embedded to have forward compatible implementations.
type UnimplementedTagLoginServer struct {
}

func (UnimplementedTagLoginServer) CreateTag(context.Context, *CreateTagRequest) (*CreateTagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTag not implemented")
}
func (UnimplementedTagLoginServer) UpdateTag(context.Context, *CreateTagRequest) (*CreateTagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTag not implemented")
}
func (UnimplementedTagLoginServer) DeleteTag(context.Context, *DeleteTagRequest) (*DeleteTagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTag not implemented")
}
func (UnimplementedTagLoginServer) SelectGroupTag(context.Context, *Empty) (*GroupTagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SelectGroupTag not implemented")
}
func (UnimplementedTagLoginServer) SelectAllTagsByGroup(context.Context, *SelectAllTagsByGroupName) (*AllTagsByGroupNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SelectAllTagsByGroup not implemented")
}
func (UnimplementedTagLoginServer) mustEmbedUnimplementedTagLoginServer() {}

// UnsafeTagLoginServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TagLoginServer will
// result in compilation errors.
type UnsafeTagLoginServer interface {
	mustEmbedUnimplementedTagLoginServer()
}

func RegisterTagLoginServer(s grpc.ServiceRegistrar, srv TagLoginServer) {
	s.RegisterService(&TagLogin_ServiceDesc, srv)
}

func _TagLogin_CreateTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagLoginServer).CreateTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagLogin_CreateTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagLoginServer).CreateTag(ctx, req.(*CreateTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagLogin_UpdateTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagLoginServer).UpdateTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagLogin_UpdateTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagLoginServer).UpdateTag(ctx, req.(*CreateTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagLogin_DeleteTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagLoginServer).DeleteTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagLogin_DeleteTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagLoginServer).DeleteTag(ctx, req.(*DeleteTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagLogin_SelectGroupTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagLoginServer).SelectGroupTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagLogin_SelectGroupTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagLoginServer).SelectGroupTag(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagLogin_SelectAllTagsByGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SelectAllTagsByGroupName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagLoginServer).SelectAllTagsByGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagLogin_SelectAllTagsByGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagLoginServer).SelectAllTagsByGroup(ctx, req.(*SelectAllTagsByGroupName))
	}
	return interceptor(ctx, in, info, handler)
}

// TagLogin_ServiceDesc is the grpc.ServiceDesc for TagLogin service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TagLogin_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tag.TagLogin",
	HandlerType: (*TagLoginServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTag",
			Handler:    _TagLogin_CreateTag_Handler,
		},
		{
			MethodName: "UpdateTag",
			Handler:    _TagLogin_UpdateTag_Handler,
		},
		{
			MethodName: "DeleteTag",
			Handler:    _TagLogin_DeleteTag_Handler,
		},
		{
			MethodName: "SelectGroupTag",
			Handler:    _TagLogin_SelectGroupTag_Handler,
		},
		{
			MethodName: "SelectAllTagsByGroup",
			Handler:    _TagLogin_SelectAllTagsByGroup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/user/service/tag/service/tag.proto",
}

const (
	TagSign_SignUserChooseTag_FullMethodName = "/tag.TagSign/SignUserChooseTag"
)

// TagSignClient is the client API for TagSign service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TagSignClient interface {
	SignUserChooseTag(ctx context.Context, in *UserChooseTagRequest, opts ...grpc.CallOption) (*UserChooseTagRequest, error)
}

type tagSignClient struct {
	cc grpc.ClientConnInterface
}

func NewTagSignClient(cc grpc.ClientConnInterface) TagSignClient {
	return &tagSignClient{cc}
}

func (c *tagSignClient) SignUserChooseTag(ctx context.Context, in *UserChooseTagRequest, opts ...grpc.CallOption) (*UserChooseTagRequest, error) {
	out := new(UserChooseTagRequest)
	err := c.cc.Invoke(ctx, TagSign_SignUserChooseTag_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TagSignServer is the server API for TagSign service.
// All implementations must embed UnimplementedTagSignServer
// for forward compatibility
type TagSignServer interface {
	SignUserChooseTag(context.Context, *UserChooseTagRequest) (*UserChooseTagRequest, error)
	mustEmbedUnimplementedTagSignServer()
}

// UnimplementedTagSignServer must be embedded to have forward compatible implementations.
type UnimplementedTagSignServer struct {
}

func (UnimplementedTagSignServer) SignUserChooseTag(context.Context, *UserChooseTagRequest) (*UserChooseTagRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignUserChooseTag not implemented")
}
func (UnimplementedTagSignServer) mustEmbedUnimplementedTagSignServer() {}

// UnsafeTagSignServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TagSignServer will
// result in compilation errors.
type UnsafeTagSignServer interface {
	mustEmbedUnimplementedTagSignServer()
}

func RegisterTagSignServer(s grpc.ServiceRegistrar, srv TagSignServer) {
	s.RegisterService(&TagSign_ServiceDesc, srv)
}

func _TagSign_SignUserChooseTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserChooseTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagSignServer).SignUserChooseTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagSign_SignUserChooseTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagSignServer).SignUserChooseTag(ctx, req.(*UserChooseTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TagSign_ServiceDesc is the grpc.ServiceDesc for TagSign service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TagSign_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tag.TagSign",
	HandlerType: (*TagSignServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SignUserChooseTag",
			Handler:    _TagSign_SignUserChooseTag_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/user/service/tag/service/tag.proto",
}
